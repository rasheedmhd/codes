Recon
1. Confirm that active recon is allowed
2. Manual scope walk through - aim is to reveal the attack surface, all the end points we can launch an attack test
3. Uncover the tech and infra+structure of the application
4. Google dork for info to advance your hacking, eg: searching for payloads

Vuln Search
https://www.cvedetails.com/documentation/

SCOPE DISCOVERY
1. whois and reverse whois
2. nslookup
3. certificates searching with crt.sh
4. Enumerate subdomains
Sublist3r - query search engines + subdomain dbs
Gobuster - brute forcer
Amass - uses DNS zone transfers, certificate parsing, search engines, and subdomain databases to
find subdomains.
Altdns - https://github.com/infosec-au/altdns/
SubBrute - brute forcer
Subfinder

Wordlists
https://github.com/danielmiessler/SecLists/
https://github.com/assetnote/commonspeak2/

5. Service Enumeration (port scanning)
- nmap, masscan
passive reconn
Shodan
Project Sonar
Censys
6. Crawl all pages - ZAP Spider
7. Third Party Hosting 
- Use google dorking to plus tools like lazys3
https://buckets.grayhatwarfare.com/
to discover open buckets, use aws cli to read the bucket contents
https://github.com/nahamsec/lazys3/ - I can rewrite it in Rust/Go/TypeScript
8. Github Recon - tools 
Gitrob (https://github.com/michenriksen/gitrob/)
TruffleHog (https://github.com/trufflesecurity/truffleHog/) 
9. OSINT
10. Fingerprinting - 
- nmap domain_name -sV
- inspecting req headers in burp proxy
- view html sc  
tools - wapplyzer, builtwith, stackshare, retire.js


OWASP WSTG - 4.1.X
1 Conduct Search Engine Discovery Reconnaissance for Information Leakage
- Google dorking
- Use different search engines bc they index differently
- Get robots.txt file
2. Fingerprinting web servers
- banner grab ( curl -I domain)
- server response adds the server name and version
- if server obscures name and version, study response header ordering
Send Malformed Requests
- study default response error msgs
- tools - netcraft, nikto, nmap

3 Review Webserver Metafiles for Information Leakage
Identify hidden or obfuscated paths and functionality through the analysis of metadata files.
Extract and map other information that could lead to a better understanding of the systems at hand
- META tags
- Robots.txt
- Sitemaps
- Security.txt
- humans.txt
curl -O -Ss https://www.google.com/robots.txt && head -n5 robots.txt

3. Enumerate Applications on Webserver
Enumerate the applications within the scope that exist on a web server.
Different base urls - use site: operator
Nonstandard ports - web apps can be hosted on different ports != 443/80
nmap -sV
nmap –Pn –sT –sV –p0-65535
Virtual Hosts - DNS allows a single IP address to be associated with one or more symbolic names.

5 Review Web Page Content for Information Leakage
Review Web Page Comments and Metadata
Identifying JavaScript Code and Gathering JavaScript Files
Identifying Source Map Files
Identify Redirect Responses which Leak Information

Identify Application Entry Points
Identify possible entry and injection points through request and response analysis.
pay attention to all HTTP requests as well as every parameter and form field that is passed to the application
make special note of any hidden form fields that are being passed to the application
Used Attack Surface Detector to end points and parameters that they receive

Map Execution Paths Through Application
ZAP spidering
ZAP offers various automatic spidering options,
which can be leveraged based on the tester’s needs:
Spider
Ajax Spider
OpenAPI Support

Fingerprint Web Application Framework
Black-Box Testing
There are several common locations to consider in order to identify frameworks or components:
HTTP headers - X-Powered-By, X-Generator
Cookies
HTML source code
Specific files and folders
File extensions
Error messages

Map Application Arch
Web Framework, Web Server, PaaS, Serverless, Microservices
Database
Port scanning the server and looking for any open ports associated with specific databases
Triggering SQL (or NoSQL) related error messages (or finding existing errors from a search engine
Load Balancers
Content Delivery Network (CDN) [to read]
If the majority of the ports are shown as “closed” (i.e, they return a RST packet in response to the initial SYN packet), this suggests that the server may not be protected by a firewall. If the ports are shown as “filtered” (i.e, no response is received when sending a SYN packet to an unused port), then a firewall is most likely to be in place.
Network Intrusion Detection and Prevention System
Web App firewall
If a cloud-based WAF is in use, then it may be possible to bypass it by directly accessing the backend server, using the same methods discussed in the Content Delivery Network section.

TESTING HTTP METHODS
Enumerate supported HTTP methods.
Test for access control bypass.
Test HTTP method overriding techniques.

How to test
Discover the Supported Methods

! all servers may respond to OPTIONS requests
some may  return inaccurate information.
Servers may support different methods for different paths.
A method might not supported for the root / directory,
doesn't indicate that it won’t be supported elsewhere.

For reliability, just make a equest with that method type,
and examine the server response. If method not permitted,
you get return a 405 Method Not Allowed status.

Some servers treate unknown methods as equivalent to GET,
so they may respond to arbitrary methods
This can occasionally be useful to evade a web application firewall,
or any other filtering that blocks specific methods.

Requests with arbitrary methods can also be made using curl with the -X option:
curl -X FOO https://example.org
Using PUT to upload files to older webservers
curl https://example.org --upload-file test.html
Using DELETE to delete files form a webserver
curl https://example.org/test.html -X DELETE


Testing for Access Control Bypass
If application redirects users to a login page with a 302 code,
it may be possible to bypass this by making a request with a different HTTP method,
such as HEAD, POST or even a made up method such as FOO.
If the web application responds with a HTTP/1.1 200 OK rather than the expected HTTP/1.1 302 Found,
it may then be possible to bypass the authentication or authorization.


Testing for HTTP Method Overriding
Some web frameworks provide a way to override the HTTP method in the request.
They achieve this by emulating the missing HTTP verbs and passing some custom headers in the requests.
The main purpose of this is to circumvent a middleware application
(such as a proxy or web application firewall)
which blocks specific methods.
The following alternative HTTP headers could potentially be used:

X-HTTP-Method
X-HTTP-Method-Override
X-Method-Override

Preflight request
A CORS preflight request is a CORS request that checks to see if the CORS protocol is understood and a server is aware using specific methods and headers.

OPTIONS	List supported HTTP methods.	Perform a CORS Preflight request.

Test HTTP Strict Transport Security
The HTTP Strict Transport Security (HSTS) feature enables a web server to inform the user’s browser, via a special response header, that it should never establish an unencrypted HTTP connection to the specified domain servers. Instead, it should automatically establish all connection requests to access the site through HTTPS. This also prevents users from overriding certificate errors.

Test Objectives
Review the HSTS header and its validity.
How to Test
Confirm the presence of the HSTS header by examining the server’s response through an intercepting proxy.
Use curl as follows:
$ curl -s -D- https://owasp.org | grep -i strict-transport-security:











